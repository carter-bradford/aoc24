/*
 * This source file was generated by the Gradle 'init' task
 */
package com.aoc.day12

import java.io.File

data class PerimeterPiece(val direction: Char, val startingCoordinate: Pair<Int, Int>)
data class Side(val startingCoordinate: Pair<Int, Int>, val endingCoordinate: Pair<Int, Int>)

data class GardenRegion(
    val cropType: Char,
    val participants: MutableList<Pair<Int, Int>>,
    val perimeterPieces: MutableList<PerimeterPiece>,
    var perimeter: Long
) {

    fun calculateRegionCost(): Long {
        return participants.size * perimeter
    }

    private fun calculateNumberOfSides(): Long {
        if (perimeterPieces.isEmpty())
            return 0
        val xSides = mutableListOf<Side>()
        val ySides = mutableListOf<Side>()
        var sideCount = 0L

        val groupedByX = perimeterPieces.filter { it.direction == 'Y' }.groupBy { it.startingCoordinate.first }
        for ((x, pieces) in groupedByX) {
            val sortedPieces = pieces.sortedBy { it.startingCoordinate.second }
            sideCount++
            var currentStart = sortedPieces[0].startingCoordinate
            if (sortedPieces.size == 1) {
                ySides.add(Side(currentStart, Pair(currentStart.first, currentStart.second + 1)))
                continue
            }

            for (i in 0 until sortedPieces.size - 1) {
                if (sortedPieces[i].startingCoordinate.second + 1 != sortedPieces[i + 1].startingCoordinate.second) {
                    ySides.add(
                        Side(
                            currentStart,
                            Pair(currentStart.first, sortedPieces[i].startingCoordinate.second + 1)
                        )
                    )
                    sideCount++
                    currentStart = sortedPieces[i + 1].startingCoordinate
                }
            }
            ySides.add(
                Side(
                    currentStart,
                    Pair(currentStart.first, sortedPieces[sortedPieces.size - 1].startingCoordinate.second + 1)
                )
            )

        }

        val groupedByY = perimeterPieces.filter { it.direction == 'X' }.groupBy { it.startingCoordinate.second }
        for ((y, pieces) in groupedByY) {
            val sortedPieces = pieces.sortedBy { it.startingCoordinate.first }
            var currentStart = sortedPieces[0].startingCoordinate
            sideCount++
            if (sortedPieces.size == 1) {
                xSides.add(Side(currentStart, Pair(currentStart.first + 1, currentStart.second)))
                continue
            }

            for (i in 0 until sortedPieces.size - 1) {
                if (sortedPieces[i].startingCoordinate.first + 1 != sortedPieces[i + 1].startingCoordinate.first) {
                    xSides.add(
                        Side(
                            currentStart,
                            Pair(sortedPieces[i].startingCoordinate.first + 1, currentStart.second)
                        )
                    )
                    sideCount++
                    currentStart = sortedPieces[i + 1].startingCoordinate

                }
            }
            xSides.add(
                Side(
                    currentStart,
                    Pair(sortedPieces[sortedPieces.size - 1].startingCoordinate.first + 1, currentStart.second)
                )
            )
        }

        val intersections = xSides.flatMap { xSide ->
            ySides.filter { ySide ->
                xSide.startingCoordinate.first < ySide.startingCoordinate.first &&
                        xSide.endingCoordinate.first > ySide.startingCoordinate.first &&
                        ySide.startingCoordinate.second < xSide.startingCoordinate.second &&
                        ySide.endingCoordinate.second > xSide.startingCoordinate.second
            }.map { Pair(xSide, it) }
        }

        sideCount += intersections.size * 2

        return sideCount
    }

    fun calculateBulkCost(): Long {
        return participants.size * calculateNumberOfSides()
    }
}

class GardenCalculator {
    val processedCrops = mutableSetOf<Pair<Int, Int>>()
    val directions = listOf(Pair(0, -1), Pair(0, 1), Pair(-1, 0), Pair(1, 0))

    fun loadGardenMap(fileName: String): List<List<Char>> {
        return File(fileName).readLines().map { it.toList() }
    }


    fun calculatePerimeter(gardenMap: List<List<Char>>, currentRegion: GardenRegion, x: Int, y: Int): Long {
        var perimeter = 0L
        // TODO: Change this to iterate over the directions
        if (x == 0 || x == gardenMap[0].size - 1) {
            perimeter++
            val perimeterX = if (x == 0) x else x + 1
            currentRegion.perimeterPieces.add(PerimeterPiece('Y', Pair(perimeterX, y)))
        }
        if (y == 0 || y == gardenMap.size - 1) {
            perimeter++
            val perimeterY = if (y == 0) y else y + 1
            currentRegion.perimeterPieces.add(PerimeterPiece('X', Pair(x, perimeterY)))
        }
        if (x - 1 >= 0 && gardenMap[y][x - 1] != currentRegion.cropType) {
            perimeter++
            currentRegion.perimeterPieces.add(PerimeterPiece('Y', Pair(x, y)))
        }
        if (x + 1 < gardenMap[0].size && gardenMap[y][x + 1] != currentRegion.cropType) {
            perimeter++
            currentRegion.perimeterPieces.add(PerimeterPiece('Y', Pair(x + 1, y)))
        }
        if (y - 1 >= 0 && gardenMap[y - 1][x] != currentRegion.cropType) {
            perimeter++
            currentRegion.perimeterPieces.add(PerimeterPiece('X', Pair(x, y)))
        }
        if (y + 1 < gardenMap.size && gardenMap[y + 1][x] != currentRegion.cropType) {
            perimeter++
            currentRegion.perimeterPieces.add(PerimeterPiece('X', Pair(x, y + 1)))
        }
        return perimeter
    }

    fun buildRegion(gardenMap: List<List<Char>>, x: Int, y: Int, gardenRegion: GardenRegion): GardenRegion {
        if (processedCrops.contains(Pair(x, y))) {
            return gardenRegion
        }
        gardenRegion.participants.add(Pair(x, y))
        processedCrops.add(Pair(x, y))
        gardenRegion.perimeter += calculatePerimeter(gardenMap, gardenRegion, x, y)

        for (direction in directions) {
            val newX = x + direction.first
            val newY = y + direction.second
            if (newX in gardenMap[0].indices && newY in gardenMap.indices &&
                !processedCrops.contains(Pair(newX, newY)) && gardenMap[newY][newX] == gardenMap[y][x]
            ) {
                buildRegion(gardenMap, newX, newY, gardenRegion)
            }
        }
        return gardenRegion
    }
}

fun main() {
    val gardenCalculator = GardenCalculator()
    val gardenMap = gardenCalculator.loadGardenMap("garden_map.txt")
    val gardenRegions = mutableListOf<GardenRegion>()
    for (y in gardenMap.indices) {
        for (x in gardenMap[0].indices) {
            if (!gardenCalculator.processedCrops.contains(Pair(x, y))) {
                val gardenRegion = GardenRegion(gardenMap[y][x], mutableListOf(), mutableListOf(), 0)
                gardenRegions.add(gardenCalculator.buildRegion(gardenMap, x, y, gardenRegion))
            }
        }
    }
    val totalCost = gardenRegions.map { it.calculateRegionCost() }.sum()
    val totalBulkCost = gardenRegions.map { it.calculateBulkCost() }.sum()
    println("Total cost of the garden is $totalCost")
    println("Total bulk cost of the garden is $totalBulkCost")
}
